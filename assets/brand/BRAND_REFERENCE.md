# EventFlux — Brand & Messaging Reference (v1.0)

> Single source of truth for naming, positioning, and copy. Literature only—use this for site, decks, PR, docs intros, and sales one-pagers.

---

## Name

**EventFlux**

### Meaning (plain)

* **Event**: We compute over events (not a broker/platform).
* **Flux**: Continuous movement—data in motion, responsive by design.

### Category (always attach to first mention)

**EventFlux — pattern-first stream processing engine (CEP) in Rust.**

### Pronunciation

/ee-vent flucks/

---

## Taglines

### Short (≤ 7 words)

* **From events to action. Fast.**
* **Pattern-first stream processing.**
* **Rust-fast stream processing.**
* **Detect, enrich, act.**

### Long (1 sentence)

* **Pattern-first stream processing engine (CEP) in Rust—filters, joins, enrichment, windows, and complex event patterns with sub-10 ms latency, without platform bloat.**
* **A compact, Rust-native stream processing engine that turns events into action through filtering, joining, enrichment, windowing, and CEP—built for on-prem and Kubernetes.**

---

## One-liner (hero)

**EventFlux is a pattern-first stream processing engine (CEP) in Rust. Compose filters, joins, enrichment, windows, and complex event patterns—and run them in milliseconds, without the overhead of a heavyweight streaming platform.**

---

## Descriptions

### Short (50–60 words)

EventFlux is a Rust-native **stream processing engine** with **pattern processing built in**. Teams define filters, joins, enrichment, windows, and complex event patterns (CEP) and execute them with low latency on-prem or in Kubernetes. Designed to be small, fast, and operable—no broker or heavyweight platform required.

### Extended (120–150 words)

EventFlux is a compact, **pattern-first stream processing engine (CEP)** built in Rust for teams who need real-time computation without the complexity of a full streaming platform. Define pipelines that **filter**, **transform**, **join**, and **enrich** data; declare **windows** and **temporal patterns**; and emit actions or insights in **sub-10 ms**. EventFlux runs cleanly on-prem or in Kubernetes, integrates with common sources and sinks, and keeps operations simple with a minimal runtime, observable metrics, and deterministic behavior. Because it’s Rust-native, EventFlux delivers consistent latency and low memory overhead while avoiding long warmups or excessive GC tuning. Start small, scale as needed, and keep control of your data plane—**no broker lock-in, no bloat, just streaming logic that ships.**

---

## Positioning Statement

For engineering teams who need real-time detection and transformation without running a heavyweight platform, **EventFlux** is a **pattern-first stream processing engine** that delivers low-latency filters, joins, enrichment, windows, and CEP in a compact Rust runtime—operable on-prem or in Kubernetes—so you can go from events to action in milliseconds.

---

## Messaging Pillars

1. **Pattern-first by design**
   Complex event patterns (sequences, absence, correlation) are built into the engine—not bolted on.

2. **Rust-fast, predictable latency**
   Consistent performance and small footprint for edge and on-prem.

3. **Essential, not excessive**
   The stream processing you need—filters, joins, enrichment, windows—without platform bloat.

4. **Operate anywhere**
   Clean self-hosted experience and Kubernetes-friendly deployment.

5. **Composable & extensible**
   Connectors for common sources/sinks; pipelines are made of clear, reusable operators.

---

## Core Value Propositions

* **Detect in real time:** CEP sequences, absence, and time-bounded rules.
* **Enrich in flight:** Join external context without breaking latency budgets.
* **Control latency:** Sub-10 ms paths on common workloads.
* **Own your runtime:** On-prem and K8s ready; no broker lock-in.
* **Keep it simple:** Minimal moving parts; clear observability and deterministic behavior.

---

## Key Capabilities (copy for slides/website)

* Filters, maps, projections
* Stateful and stateless operators
* Stream-to-table and stream-to-stream joins
* Enrichment via external stores and caches
* Tumbling, sliding, session windows; watermarking and late-data handling
* CEP patterns: sequence, absence, correlation, time-bounded triggers
* Connectors for common sources and sinks (extensible)
* Exactly-once/at-least-once modes (where supported)
* Metrics and tracing hooks for observability

---

## Why Rust (talk track)

* **Predictable latency** (no GC pauses)
* **Memory safety** with low overhead
* **Small binaries & fast starts**
* **Edge/on-prem friendly** operations

---

## Audience & ICP (who this is for)

* **Platform/infra teams** that need real-time computing but not a full streaming platform.
* **Fraud/risk and security teams** that require pattern detection and correlation.
* **Observability/SRE teams** correlating events across services and time windows.
* **IoT/telemetry teams** processing sensor data with enrichment at the edge.

---

## Objection Handling (with crisp replies)

* **“Is this a broker?”** No—EventFlux is a **processing engine** that connects to your existing sources/sinks.
* **“Do I need Kafka/Pulsar?”** No, but EventFlux integrates cleanly if you have them.
* **“Is this just CEP?”** CEP is integrated, but EventFlux also handles general transforms, joins, enrichment, and windows.
* **“Will it run on-prem?”** Yes—self-hosted and Kubernetes deployments are first-class.
* **“Why not X big platform?”** If you need the platform, use it; if you need **results without bloat**, use EventFlux.

---

## Differentiators

* **CEP is native, not an add-on**
* **Rust performance without GC tuning**
* **Minimal surface area** vs. full platforms
* **Operator-centric mental model** (filters, joins, windows, patterns)
* **On-prem & edge-friendly** footprint

---

## Tone & Voice

* **Concrete > vague.** Say “filters, joins, enrichment, windows, patterns,” not “powerful insights.”
* **Confident, not loud.** Let proof points carry the message.
* **Builder-friendly.** Speak to engineers; avoid buzzwords.
* **Consistent category phrase.** Always pair **EventFlux** with **“stream processing engine (CEP)”** on first mention.

---

## Boilerplate (press/about)

**Short:**
EventFlux is a pattern-first **stream processing engine (CEP)** built in Rust. It turns events into action through filtering, joining, enrichment, windowing, and complex event patterns—at low latency and without the bloat of a heavyweight platform.

**Long:**
EventFlux is a compact, Rust-native **stream processing engine** that brings **pattern processing (CEP)** into the core runtime. Teams use EventFlux to compose filters, maps, joins, enrichment, windows, and temporal patterns, then execute them in milliseconds on-prem or in Kubernetes. With predictable performance, straightforward operations, and extensible connectors, EventFlux delivers the essentials of real-time computation—without platform lock-in or broker overhead.

---

## SEO / Keywords (for meta & headlines)

* stream processing engine
* complex event processing (CEP)
* real-time event processing
* Rust stream processing
* windows and watermarking
* joins and enrichment
* event correlation / pattern detection
* on-prem stream processing / Kubernetes stream processing

---

## Visual Identity Cues (non-design guidance)

* **Icon:** branching pipeline / signal graph (immediately reads “processing”).
* **Avoid:** waves/cloth metaphors (weave/loom), generic clouds.
* **Lockup:** “EventFlux | stream processing engine (CEP)” on first-view placements.
* **Color:** modern, high-contrast palette; emphasize clarity/readability.

---

## CTA Language (examples)

* **Get started**
* **Read the quickstart**
* **See patterns in action**
* **Deploy on Kubernetes**
* **Compare latency**

---

## Consistency Checklist (first 90 days)

* Use **EventFlux — pattern-first stream processing engine (CEP) in Rust** on every first mention.
* Repeat the five operator nouns in intros: **filters, joins, enrichment, windows, patterns**.
* Keep proof-point latency line consistent (e.g., **sub-10 ms** on common workloads).
* Ensure org bios, site meta titles, PR boilerplates match this reference.
* Avoid platform language; emphasize **engine**.

---

## Change Log

* **v1.0** — Initial brand and messaging reference.
